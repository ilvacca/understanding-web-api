# Understanding WebAPIs architectures with Python, Flask & SQLAlchemy

## Introduction
Any software is nowadays embedded between Web Servers and WebAPIs. Communication between services, applications and (web) apps often takes place using **RESTful HTTP protocols**.

The first Python approaches to this world usually occur with **Flask**. A **micro-framework** that - _fortunately_ - allows us to create web applications potentially **far from the monolithic style**.
In fact, when the application starts to become more robust, it emerges the need to **define** and **design an architecture**.

In this repository a small collection of **best practices** and examples of **architectural patterns** to promote the orderly development of WebAPIs.

## Examples
TODO

### 1. Our first Flask server
This is the easiest example that can be realized in Flask: a website with a single route.

#### 1.1. Routes
| NAME | ROUTE |
|---|---|
| Index | / |

### 2. Multiple routing

### 3a. Multiple routing with HTML

### 3b. Multiple routing with HTML template

### 4. Passing arguments

### 5. Responding with a JSON (I)

### 6. Passing arguments in a compact way

### 7. Responding with a JSON (II)

### 8. Read data from files

### 9. Read data from a DB

### 10. An architecture with DAO module (SQLite)

### 11. An architecture with DAO and Models (SQLAlchemy)

## Credits

*These resources were created with* ‚ù§ *by Alessio Vaccaro*.
[Website](https://www.alessiovaccaro.com) | [LinkedIn](https://www.linkedin.com/in/alessio-vaccaro/) 